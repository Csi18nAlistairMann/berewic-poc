<?php
/*
  This endpoint will initially live at http://berewic.pectw.net

  The output will reflect the presence or absence in the inbound
  connections headers of berewic information.

  This endpoint ultimately grows into /Bob's server/: he hosts content here
  which he wishes to have protected using berewic bonds.
*/
//
// globals
error_reporting(E_ALL);

// fakes! don't use
define('BEREWIC_BTA_1', 'https://z4r56iqh3gnhj67bn.onion:8443/proposal/35cb904aced147bd1230965501af4306ac5204db/64be35a9db5e5f09f40a058b9f27c5ed112ea49c');
define('BEREWIC_BTA_2', 'https://berewic.mpsvr.com:8443/proposal/4025061200627151c0c2b7b80d7af47b3b5c8bd2/e8ebaa9cb957844658dd0bcea2aeae6ffb1e2349');
define('BEREWIC_SECRET', 'thisisasecret');

define('CONST_HEADER_BEREWIC_BONDED', 'berewic-bonded');
define('CONST_HEADER_KEY_MARKER', 'berewic-');
define('CONST_HEADER_KEY_MARKER_SZ', strlen(CONST_HEADER_KEY_MARKER));
define('CONST_HEADER_KEY_MAX_SZ', 32);
define('CONST_HEADER_VALUE_MAX_SZ', 255);
define('CONST_HEADER_TXT_VERSION', CONST_HEADER_KEY_MARKER . 'version');
define('CONST_HEADER_TXT_ROLE', CONST_HEADER_KEY_MARKER . 'role');
define('CONST_REDIRECT_HEADER', CONST_HEADER_KEY_MARKER . 'bond-transport-agent');
define('CONST_NO_VERSION', '0.0');
define('CONST_ROLE_TXT_CLIENT', 'client');
define('CONST_ROLE_TXT_SERVER', 'server');
define('CONST_HEADER_FORCED_KEY_MARKER', 'forced-berewic-');
define('CONST_HEADER_FORCED_KEY_MARKER_SZ', strlen(CONST_HEADER_FORCED_KEY_MARKER));
define('CONST_HEADER_TXT_TEMP_RATE', CONST_HEADER_FORCED_KEY_MARKER . 'use-this-rate');
define('CONST_RATE_TXT_ZERO', 'zero');
define('CONST_RATE_TXT_LOW', 'low');
define('CONST_RATE_TXT_NORMAL', 'normal');
define('CONST_RATE_DEFAULT', CONST_RATE_TXT_NORMAL);
define('CONST_TXT_IDV1', 'idv1');
define('CONST_TXT_RATEV1', 'ratev1');
define('CONST_TXT_AUTHV1', 'authv1');

define('CONST_VERSION', '0.1');
define('CONST_ROLE', CONST_ROLE_TXT_SERVER);

define('ERR_HEADER_KEY_TOO_LARGE', 1000);
define('ERR_HEADER_KEY_TOO_LARGE_MSG',
	   'Headers have a key equal or longer than ' . CONST_HEADER_KEY_MAX_SZ .
	   ' characters');
define('ERR_HEADER_VALUE_TOO_LARGE', 1001);
define('ERR_HEADER_VALUE_TOO_LARGE_MSG',
	   'Headers have a value equal or longer than ' . CONST_HEADER_VALUE_MAX_SZ .
	   ' characters');
define('ERR_HEADER_ROLE_NOT_RECOGNISED', 1002);
define('ERR_HEADER_ROLE_NOT_RECOGNISED_MSG', 'Role not "' . CONST_ROLE_TXT_CLIENT .
	   '" or "' . CONST_ROLE_TXT_SERVER . '"');
define('ERR_HEADER_KEY_UNKNOWN', 1003);
define('ERR_HEADER_KEY_UNKNOWN_MSG', 'Headers have a key unknown to this system');
define('ERR_HEADER_TEMP_RATE_UNKNOWN', 1004);
define('ERR_HEADER_TEMP_RATE_UNKNOWN_MSG', 'Headers have a key unknown to this system');

//
// classes
class BerewicHeaders {
	private $isClient = false;
	private $isServer = false;
	private $version = CONST_NO_VERSION;
	private $shenanigans_arr = array();
	function getShenanigans() {
		if (sizeof($this->shenanigans_arr) === 0)
			return false;
		else
			return true;
	}

	function addShenanigan($error) {
		$this->shenanigans_arr[] = $error;
	}

	function printShenanigans() {
		foreach ($this->shenanigans_arr as $value) {
			switch ($value) {
			case ERR_HEADER_KEY_TOO_LARGE:
				echo ERR_HEADER_KEY_TOO_LARGE_MSG . "\n";
				break;
			case ERR_HEADER_VALUE_TOO_LARGE:
				echo ERR_HEADER_VALUE_TOO_LARGE_MSG . "\n";
				break;
			case ERR_HEADER_ROLE_NOT_RECOGNISED:
				echo ERR_HEADER_ROLE_NOT_RECOGNISED_MSG . "\n";
				break;
			case ERR_HEADER_KEY_UNKNOWN:
				echo ERR_HEADER_KEY_UNKNOWN_MSG . "\n";
				break;
			case ERR_HEADER_TEMP_RATE_UNKNOWN:
				echo ERR_HEADER_TEMP_RATE_UNKNOWN_MSG . "\n";
				break;
			default:
				echo "Unrecognised error\n";
			}
		}
	}

	function setRole($value) {
		$value = strtolower($value);
		if ($value === CONST_ROLE_TXT_SERVER) {
			$this->isClient = false;
			$this->isServer = true;
		} elseif ($value === CONST_ROLE_TXT_CLIENT) {
			$this->isClient = true;
			$this->isServer = false;
		} else {
			$this->isClient = false;
			$this->isServer = false;
			$this->addShenanigan(ERR_ROLE_NOT_RECOGNISED);
		}
	}

	function setVersion($value) {
		$this->version = $value;
	}

	function getVersion() {
		return $this->version;
	}

	function announceSelf() {
		// won't work as client
		header(CONST_HEADER_TXT_VERSION . ': ' . $this->version);
		if ($this->isClient === true && $this->isServer === false) {
			header(CONST_HEADER_TXT_ROLE . ': ' . CONST_ROLE_TXT_CLIENT);
		} elseif ($this->isClient === false && $this->isServer === true) {
			header(CONST_HEADER_TXT_ROLE . ': ' . CONST_ROLE_TXT_SERVER);
		} else {
			// something happened (something happened)
		}
	}
}

class InHeaders extends BerewicHeaders {
	private $headers_passed = array();
	private $headers_seen = 0;
	private $forced_rate = CONST_RATE_DEFAULT;

	function __construct($headers) {
		// Takes in an array of k=>v pairs as generated by
		// apache_request_headers(), size checks them, and
		// store those that pass.
		foreach ($headers as $header => $value) {
			if (strtolower(substr($header, 0, CONST_HEADER_KEY_MARKER_SZ)) ===
				CONST_HEADER_KEY_MARKER) {
				// sanity check for sizes
				$key = strtolower(substr($header, 0, CONST_HEADER_KEY_MAX_SZ));
				if (strlen($key) === CONST_HEADER_KEY_MAX_SZ)
					$this->addShenanigan(ERR_HEADER_KEY_TOO_LARGE);
				$value = substr($value, 0, CONST_HEADER_VALUE_MAX_SZ);
				if (strlen($value) === CONST_HEADER_VALUE_MAX_SZ)
					$this->addShenanigan(ERR_HEADER_VALUE_TOO_LARGE);
				// make a copy
				$this->headers_passed[] = [$key => $value];
				$this->incHeadersSeen();
				//
				if ($key === CONST_HEADER_TXT_VERSION)
					$this->setVersion($value);
				elseif ($key === CONST_HEADER_TXT_ROLE)
					$this->setRole($value);
				else
					$this->addShenanigan(ERR_HEADER_KEY_UNKNOWN);
			} elseif (strtolower(substr($header, 0,
										CONST_HEADER_FORCED_KEY_MARKER_SZ)) ===
					  CONST_HEADER_FORCED_KEY_MARKER) {
				$key = strtolower(substr($header, 0, CONST_HEADER_KEY_MAX_SZ));
				if ($key === CONST_HEADER_TXT_TEMP_RATE) {
					$this->setForcedRate($value);
				}
			}
		}
	}

	function incHeadersSeen() {
		$this->headers_seen++;
	}

	function getHeadersSeen() {
		return $this->headers_seen;
	}

	function getHeadersPassed() {
		return $this->headers_passed;
	}

	function setForcedRate($value) {
		$value = strtolower($value);
		switch ($value) {
		case CONST_RATE_TXT_ZERO:
		case CONST_RATE_TXT_LOW:
		case CONST_RATE_TXT_NORMAL:
			$this->forced_rate = $value;
			break;
		default:
			$this->addShenanigan(ERR_HEADER_TEMP_RATE_UNKNOWN);
			$this->forced_rate = CONST_RATE_TXT_NORMAL;
		}
	}

	function getForcedRate() {
		return $this->forced_rate;
	}
}

class OutHeaders extends BerewicHeaders {
	private $cryptoTransportAgents = array();

	function __construct($version, $role, $ip_address, $ratev1) {
		$this->setVersion($version);
		$this->setRole($role);
		$idv1 = hash('crc32', $ip_address);
		$authv1 = hash('ripemd160', $idv1 . $ratev1 . BEREWIC_SECRET);

		$params = '?' . CONST_TXT_IDV1 . '=' . $idv1 .
			'&' . CONST_TXT_RATEV1 . '=' . $ratev1 .
			'&' . CONST_TXT_AUTHV1 . '=' . $authv1;
		$this->addCryptTransportAgent('20', BEREWIC_BTA_1 . $params);
		$this->addCryptTransportAgent('10', BEREWIC_BTA_2 . $params);
	}

	function addCryptTransportAgent($preference, $location) {
		if (!isset($this->cryptoTransportAgents[$preference]))
			$this->cryptoTransportAgents[$preference] = array();
		$this->cryptoTransportAgents[$preference][] = $preference . ',' . $location;
	}

	function pleaseBond() {
		$rv = array();
		sort($this->cryptoTransportAgents);
		foreach ($this->cryptoTransportAgents as $agents) {
			foreach ($agents as $location) {
				header(CONST_REDIRECT_HEADER . ': ' . $location, false);
				$rv[] = $location;
			}
		}
		return $rv;
	}
}

//
// Subroutines

function main($headers) {
	$inHeaders = new InHeaders($headers);
	if ($inHeaders->getShenanigans() === true) {
		header(CONST_HEADER_BEREWIC_BONDED . ": false");
		echo "Bonding headers seen but shenanigans detected:\n";
		$inHeaders->printShenanigans();

	} elseif ($inHeaders->getHeadersSeen() === 0) {
		header(CONST_HEADER_BEREWIC_BONDED . ": false");
		$id = '';
		if (isset($_SERVER['HTTP_X_FORWARDED_FOR']))
			$id .= $_SERVER['HTTP_X_FORWARDED_FOR'];
		if (isset($_SERVER['REMOTE_ADDR']))
			$id .= $_SERVER['REMOTE_ADDR'];

		$outHeaders = new OutHeaders(CONST_VERSION, CONST_ROLE, $id,
									 $inHeaders->getForcedRate());
		$outHeaders->announceSelf();
		$whatsaid = $outHeaders->pleaseBond();

		echo "No bonding headers seen\n";
		if (sizeof($whatsaid) === 0) {
			echo "Not configured with any Bonding Transport Agents\n";

		} else {
			echo "The following Bonding Transport Agents are configured:\n";
			foreach ($whatsaid as $agent) {
				echo $agent . "\n";
			}
		}

	} else {
		header(CONST_HEADER_BEREWIC_BONDED . ": true");
		echo "Congratulations! This connection is bonded\n";
	}

	echo "Hello, world!\n";
}

//
// entry point

main(apache_request_headers());
?>
